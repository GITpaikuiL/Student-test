静态变量不会被释放 （先定义局部变量）
浮点数【实数】
float 4  double 8
整数
int 4     short  2    long int 8   float 32     double64     char8      sunsigned char8
字符
char 1
复合型数据
结构体   枚举    共用体
变量必须初始化
科学计数法   字符  单个字符是用单引号‘   ’ 字符串是用双引号''
进制 %d是以十进制输出     %x是以十六进制输出  %o是以八进制输出
注意格式   一点要敲空格
char  定义一个 字符（不能是字符串）  是' a'这种类型  输出printf 用  %c\n 
printf("字符串\n") \n\n\n\n\n\n\n\n
printf("%d",l)   %输出控制符  d是十进制    可变0x   0    几进制          l是参数符号可变   
Printf（"输出控制符1，输出控制符2。。。"，输出参数1，输出参数2）输出控制符和输出参数的个数必须一一对应
printf("输出控制符 非输出控制符",输出参数);
     输出控制符保函如下
%d   int
%ld   long int
%c   char
%f    float
%lf   double 
%s   字符串 
%x 或者 %#x   ox表示16进制  %#x推荐使用
c常用语言预处理命令   typedef  unsigned char u8;
                                   typedef unsigned int u16;
重新定义一些常用的关键词，可以增强程序的可移植性，因为在不同的编译软件1上面，c语言的数据类型的关键词的位宽是不一样的
延时函数 void delay（u16  i）//大约延时10us{while（i--）}
0  1 可以表示数据 也可以表示指令
宏定义  #define
_crol_(a,b);循环左移函数，a是左移的值（开始的位置)，b是左移的位数，包含在intrins.h库函数里面
_cror_(a,b);循环右移函数，a是右移的值(开始的位置)，b是右移的位数，包含在intrins.h库函数里面
~反函数 
scanf()[提供键盘将数据输入到变量中]
   两种用法
	用法一：scanf("输出控制符",输出参数);
	功能 ： 将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中
静态数码管      
共阴数码管码表 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71，0x00      
	          0  	  1      2         3      4      5      6       7      8     9        A    B      C       D      E      F       无显示      
运算符
/（ 除法）           %（取余数）的区别  
 _nop_  短暂延时函数   调用 <intrins.h>   函数
指针型本身就是一个变量，在这个变量中存放的指向另一个数据的地址。这
个指针变量要占用一定的内存单元，对不同的处理器其长度不一样，在 C51 中它的长度一般为 1~3 个字节

if默认 只控制一个语句    控制多个  花括号
 if
else if() 
      a;
else if()
      b;
else
       c;

运算符 优先级 算术>关系>逻辑>赋值
对于for循环语句 
for(x；a；d)
语句
先 x a 语句 d    d标志执行完 循环一次结束
for(i=1;1<=4;i++)
      sum=sum+1
输出结果  10
也只是和if一样一个语句   如果要用多个语句   要 用花括号 包起来  {   }
for（）
{
}
 i+=2 等价 与 i= i+2
强制类型转换
   格式       (数据类型)(表达式)
   功能       把表达式的值强制转化为前面所执行的数据类型
   例子       (int)(4.5+2.2)   结果是6
                 (float)(5)  结果是5.0000000
浮点型 可能丢失精度  
while  的 用法
while（）


do while（）

break用法
只能终结离他最近的循环（跳出循环）   在多个 函数switch中最近的那个
break不能直接用于if，除非if属于循环内部的一个子句
continue
用于执行一次语句后  直接终结本次循环   开始去下一次循环



数组  a 【】 只是表示 第一个元素的地址
正确写法      把一个数组中的值 复制到另一个数组   正确写法
{
for(i=0;i<5;i++)
	b[i]=a[i]
}


二维数组与一维数组的输出    用循环函数
为什么说   多维数组不存在
int a[3] [4] ;
该数组是含有3个元素的一维数组
只不过每个元素都可以再分成4个小元素
int a[3] [4] [5];
该数组是含有3个元素的一维数组
只不过每个元素都是4行5列的二维数组
定义一维数组	
	为n个变量连续分配储空间
	所以的变量数据类型必须相同
	所以变量所占的字节大小必须相等
只有在定义数组的同时才能整体赋值，其他情况赋值都是错误
	

算术 运算符
关系 运算符
逻辑 运算符   ！(非)      &&（并且）   ||（或）
赋值 运算符
       
函数的定义
逻辑上：能够完成特定功能的独立的代码块
物理上：能够接收数据也可以不接受
	进行接收的数据处理
	数据处理的结果返回
  描述；工具，为了解决大量类似的问题而设计的
分类
 参函数  无参函数
 有返回值函数   无返回值函数
 库函数   用户自定函数
 值传递函数   地址传递函数
 普通函数   主函数（main函数）
	一个程序必须有且只能有一个主函数
	主函数可以调用普通函数   普通函数不能调用主函数
	普通函数可以调用普通函数
	主函数是程序的入口，也是程序的出口
注意的问题
函数引用的方式
注意
函数功能模块化
 
变量
全局变量和局部变量

指针
*p
{
	int *P;
	int i=3;
	p=&i;   //p保存了i的地址，因此p指向i
	            //p不是i，i也不是p，更准确来说：修改p的值不影响i的值，修改i的值 
}


1指针就是地址，地址就是指针
2地址就是内存单元的编号
3指针变量是存放地址的变量   就是存放内存单元编号的变量
4指针和指针变量是两个不同的概念
5但是要注意:通常我们叙述时会把指针变量简称为指针，实际上他们的含义不一样

关于内存泄漏  指针free内存释放（为什么电脑越用越卡）

关于指针的数据互换
 
星号***的含义
1.乘法
2.定义指针变量
3.指针运算符放在已经定义好的指针变量前面


实参和形参的区别 
（主函数和其他函数中的参数不一致） 原因就是地址的区别 
（全部变量可以改变）（局部变量不能改变）
 
   指针:
 指针的重要性
 表示一-些复杂的数据结构
 快速的传递数据
 使函数返回一个以上的值
 能直接访问硬件
 能够方便的处理字符串
 是理解面向对象语言中引用的基础.

如何通过被调函数修改主调函数普通变量的值
1.实参必须为该普通变量的地址
2.形参必须为指针变量
3.在被调函数中通过
*形参名=..
的方式就可以修改主调函数相关变量的值


在一个函数内部如果定义的局部变量的名字和全局变量名
样时，局部变量会屏蔽掉全局变量____注意 定义

指针与下标
指针和数组


确定一维数组需要几个参数  
（首地址(指针)    长度  ）
在数组中  *（指针名+i）等价与 指针名【i】也等价与数组的名字【i】

指针变量的运算
	指针变量不能相加 不能相称  不能相除
	如果两个指针变量指向的是同一块连续空间中的不同存储单元,
                则这两个指针变量才可以相减

预备知识
一个指针变量到底占几个字节
函数        sizeof(数据类型)
功能  返回值就是该数据类型所占的字节数
例子:   sizeof(int) = 4              sizeof (char) = 1        sizeof (double)二8

 sizeof(变量名)
 返回值就是该变量所占的字节数
 
printf("%d\n",sizeof(参数))


动态内存分配
传统数组的缺点:
1. 数组长度必须事先制定，且只能是常整数，不能是变量
例子:
int
a[5]; I //0k
int len = 5; int a[len]; //e
error
2.传统形式定义的数组，该数组的内存程序员无法手动释放
   在一个函数运行期间，系统为该函数中数组所分配的空间
  会一直存在，直到该函数运行完毕时，数组的空间才会被系统释放
3.数组的长度一旦定义，其长度就不能在更改数组的长度不能在函数运行的过程中动态的扩充或缩小
4.A函数定义的数组，在A函数运行期间可以被其它函数使用，
但A函数运行完毕之后，A函数中的数组将无法在被其他函数使用
 传统方式定义的数组不能跨函数使用

malloc  动态内存分配 
/*
malloc是memory(内存) allocate (分配)的缩写
# include <stdio. h>
# include <malloc. h> //不能省
int main (void)
int i = 5; //分配了4个字节静态分配
int * p = (int *)malloc(4) ; 
/*
1.    要使用malloc函数， 必须添加<malloc. h>这个头文件
2.    malloc函数只有一个形参，并且形参是整型
3.     4表示请求系统为本程序分配4个字节
4.     malloc函数只能返回第一一个字节的地址
5.     12行分配了8个字节，p变量占4个字节， p所指向的内存也占4个字节
6.     p本身所占的内存是静态分配的，p所指向的内存是动态分配的

realloc函数  扩充内存
realloc（变量名，内存大小）
大变小 原数据全无
小变大 原数据全有

动态的构造一个一维数组


多级指针

程序运行后会释放 静态变量
静态变量不能跨函数使用

结构体

   为了模拟一些复杂的事物    普通的基本类型无法满足实际需求
   什么叫结构体
   将一些基本类型数据结合在一起形成的一个新的复合数据类型
 
结构体的三种  定义


 struct  变量名
作用  定义数据类型 
在内部进行赋值
struct 变量名
{	
     int age;
     float  score;
     char   sex;
}；
只是定义了一个新的数据类型，并没有定义变量

结构体变量的赋值和初始化


struct Student
{
int age;
float score;
char sex;
}；
int main (void)
{
 struct Student st = {80， 66.6， ’F’} ; //初始化定 义的同时赋初值
 struct Student st2;
 st2. age= 10;
 st2. score = 88;
 st2. sex= F’;
 printf("%d %f %c\n"，st. age，st. score，st. sex) ;
 printf("%d %f %c\n' ，st2. age，st2. score, st2. sex) ;
 return 0;
}

  怎样使用结构体变量赋值和初始化
  定义的同时可以整体赋初值
  如果定义完之后，则只能单个的赋初值
  如何取出结构体变量中的每-一个成员
1.结构体变量名.成员名
2.指针变量名->成员名
在计算机内部会被转化为（*指针变量名）.成员名的方式来执行
这两种方式是等价的
pat_>age   在计算机内部会被转化为(*pat).age

pat_>age的含义
pst所指向的那个结构体变量中的age这个成员


在c语言中（因为编译码原因）浮点数不能被精确存储


一个字节（八位），一个地址


数组不可以加取地址符  数组已经表示  首地址



枚举     enum
  把一个事物的所以可能 列举出来


链表：
                算法
                通俗定义：解题的方法和步骤
                狭义定义：对存储数据的操作
                广义定义：广义的算法也叫泛型
                                 无论数据是如何储存的，对数据操作都是一样的
                 
                我们至少通个两种结构来存储数据
                数组
              
                链表



逻辑符 &  与 &&
          |    与  || 双目运算符




什么是指针，什么是地址 ，什么是指针变量，三者之间什么关系？
地址是内存单元的编号  指针就是地址  指针和地址是同个概念
指针变量是存放内存单元编号的变量  指针变量和指针是两个完全不同的概念


























                     
